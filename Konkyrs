# Будем приобщаться к стилю Python 3...
from __future__ import print_function

# Импорт среды SimPy
import simpy

# Для генерации случайных чисел
import random


# Инициализация среды моделирования
env = simpy.Environment()


# Ресурс обслуживания; в данном случае - capacity - число касс,
# которые обслуживают покупателей
bcs = simpy.Resource(env, capacity=6)


# Длительность покупки\получения услуги
# Здесь и всюду в этой модели мы полагаем, что единица модельного 
# времени соответствует 1 секунде реального времени
SERVICE_DURATION = 20 * 60 # т.е. максимальная длительность обслуживания 20 мин
# В реальности - время обслуживания равномерно распределенная случайная величина
# на интервале [0, 20 * 60]

# Интервал появления нового посетителя магазина
ARRIV_INTER = 4 * 60
# В реальности - время появления нового посетителя равномерно распределенная
# случайная величина на интервале [0, 4 * 60]

# Время пока посетителей запускают в магазин (10 часов)
# После 10 часов работы магазин закрывают и обслуживают только оставшихся, 
# если таковые имеются...
CONSUMER_TIME = 3600 * 10
# Источник посетителей предполагает, что
# посетители приходят 10 часов подряд от начала работы магазина, 
# далее поступление новых посетителей прекращается
def source_men(env):
    ind = 0
    while env.now < (CONSUMER_TIME - ARRIV_INTER): # Посетители приходят 10 часов подряд CONSUMER_TIME = 3600*10
        ind += 1
        yield env.timeout(random.randint(0, ARRIV_INTER))
        man = Man(env, bcs, name='Mr:%s' % ind)
        env.process(man.run())
        # Объект этого класса - посетитель магазина
class Man(object):
    def __init__(self, env, res, name='default'):
        self.name = name  # Имя посетителя, мы же должны их различать !!!
        self.env = env  # Среда моделирования
        self.res = res  # используемый при моделировании ресурс, в данном случае - касса

    def run(self):
        # сделаем счетчики статистики глобальными, они нужны для построения 
        # графиков после моделирования
        global myquelen, maxwaits, timelist_q,timelist_w
        # человек пришел и сразу встал в очередь: она увеличилась на 1
        myquelen += 1
        print(u"Добрый день! Меня зовут {0} и я \
прибыл в магазин в {1} (время)".format(self.name, self.env.now))
        # Запомним время, чтобы посчитать потом время пребывания в очереди
        time = self.env.now
        # Запрос свободной кассы...
        with self.res.request() as req:
            # Нет ничего свободного... в очередь...
            yield req
            # Свободная касса появилась...
            # Человек поступает на обслуживание и очередь уменьшается на 1
            myquelen -= 1
            # запомним текущую длину очереди
            queue.append(myquelen)
            # запомним текущее время
            timelist_q.append(self.env.now)
            # вспомогательная переменная, (wait-time) - время, проведенное в очереди
            wait = self.env.now
            # время обслуживание - просто случайное число, генерируем его
            serving_duration = random.randint(0, SERVICE_DURATION)
            # обслуживаемся в кассе...
            yield self.env.timeout(serving_duration)
            # Обслужились
            print(u"Я {0}; Я обслуживался {1} единиц времени, и \
ждал в очереди {2} единиц времени".format(self.name, serving_duration, wait-time))
            # Запомним время проведенное в очереди
            maxwaits.append(wait-time)
            # Запомним текущее время
            timelist_w.append(self.env.now)
            print(u"Меня обслужили и сейчас ({0} -- текущее время) \
я покидаю магазин.".format(self.env.now))
